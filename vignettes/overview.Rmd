---
title: "The GenomicDataCommons Package"
author: "Sean Davis & Martin Morgan"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
    theme: readable
abstract: >
  The NCI [Genomic Data Commons](https://gdc.nci.nih.gov/) 
       
vignette: >
  %\VignetteIndexEntry{Introduction to Accessing the NCI Genomic Data Commons}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
 
```{r init, results='hide', echo=FALSE, warning=FALSE, message=FALSE}
library(knitr)
```


# What is the GDC?

From the [Genomic Data Commons (GDC) website](https://gdc.nci.nih.gov/about-gdc):

The National Cancer Institute's (NCI's) Genomic Data Commons (GDC) is
a data sharing platform that promotes precision medicine in
oncology. It is not just a database or a tool; it is an expandable
knowledge network supporting the import and standardization of genomic
and clinical data from cancer research programs.

The GDC contains NCI-generated data from some of the largest and most
comprehensive cancer genomic datasets, including The Cancer Genome
Atlas (TCGA) and Therapeutically Applicable Research to Generate
Effective Therapies (TARGET). For the first time, these datasets have
been harmonized using a common set of bioinformatics pipelines, so
that the data can be directly compared.

As a growing knowledge system for cancer, the GDC also enables
researchers to submit data, and harmonizes these data for import into
the GDC. As more researchers add clinical and genomic data to the GDC,
it will become an even more powerful tool for making discoveries about
the molecular basis of cancer that may lead to better care for
patients.

The
[data model for the GDC is complex](https://gdc.cancer.gov/developers/gdc-data-model/gdc-data-model-components),
but it worth a quick overview. The data model is encoded as a
so-called property graph. Nodes represent entities such as Projects,
Cases, Diagnoses, Files (various kinds), and Annotations. The
relationships between these entities are maintained as edges.  Both
nodes and edges may have Properties that supply instance details.  The
GDC API exposes these nodes and edges in a somewhat simplified set
of
[RESTful](https://en.wikipedia.org/wiki/Representational_state_transfer) endpoints.

# Basic design

This package design is meant to have some similarities to the "hadleyverse" approach of dplyr. Roughly, the functionality for finding and accessing files and metadata can be divided into:

1. Simple query constructors based on GDC API endpoints.
2. A set of verbs that when applied, adjust filtering, field selection, and faceting (fields for aggregation) and result in a new query object (an endomorphism)
3. A set of verbs that take a query and return results from the GDC

In addition, there are exhiliary functions for asking the GDC API for information about available and default fields, slicing BAM files, and downloading actual data files.


+-------------------------------------+-------------------------------------+
| Basic Operation                     | Applicable Functions or Methods[^1] |
+=====================================+=====================================+
| Forming a query                     | - Generic `query()`                 |
|                                     | - Endpoint-specific convenience functions |
| - These operations produce a        |     - `projects()`                 |
| `GDCQuery` class object             |     - `cases()`                    |
|                                     |     - `files()`                    |
|                                     |     - `annotations()`              |
+-------------------------------------+------------------------------------+
| Manipulating a `GDCQuery` object    | - `filter()`                       |
|                                     | - `facet()`                        |
| - filtering                         | - `select()`                       |
| - adding facets for aggregation     | - `archive()`                      |
|   (counting)                        |                                    |
| - selecting return fields           |                                    |
| - selecting archive ("legacy" or    |                                    |
|   "default")                        |                                    |
+-------------------------------------+------------------------------------+
| Finding fields for filtering        | - `mapping()`                      |
| and selecting                       | - `available_fields()`             |
|                                     | - `default_fields()`               |
+-------------------------------------+------------------------------------+
| Calling the GDC API to "execute" a  |                                    |
| `GDCQuery`                          | - `results()`                      |
| to fetch results                    | - `count()`                        | 
|                                     | - `response()`                     | 
+-------------------------------------+------------------------------------+
| Return aggregations (facets)        | - `aggregations()`                 |
+-------------------------------------+------------------------------------+
| Fetch a file manifest for bulk      | - `manifest()`                     |
| downloading using the               |                                    |
| GDC Transfer Tool                   |                                    |
+-------------------------------------+------------------------------------+
| Downloading data files              | - `gdcdata()`                      |
|                                     | - `transfer()`                     |
+-------------------------------------+------------------------------------+
| BAM slicing                         | - `slicing()`                      |
+-------------------------------------+------------------------------------+


Table: Overview of functionality for querying and retrieving metadata from the NCI Genomic Data Commons.



[^1]: See individual function and methods documentation for specific details.

# Quickstart

```{r libraries, message=FALSE}
library(GenomicDataCommons)
library(DT)
```

# Usage

There are two main classes of operations when working with the NCI GDC.  

1. [Querying metadata and finding data files](#querying-metadata) (e.g., finding all gene expression quantifications data files for all colon cancer patients).
2. [Transferring raw or processed data](#datafile-access-and-download) from the GDC to another computer (e.g., downloading raw or processed data)

Both classes of operation are reviewed in detail in the following sections.

## Querying metadata

Vast amounts of metadata about cases (patients, basically), files, projects, and so-called annotations are available via the NCI GDC API. Typically, one will want to query metadata to either focus in on a set of files for download or transfer *or* to perform so-called aggregations (pivot-tables, facets, similar to the R `table()` functionality). 

Querying metadata starts with [creating a "blank" query](#creating-a-query). One will often then want to [`filter`](#filtering) the query to limit results prior to [retrieving results](#retrieving-results). The GenomicDataCommons package has [helper functions for listing fields](#fields-and-values) that are available for filtering. 

In addition to fetching results, the GDC API allows [faceting, or aggregating,](#facets-and-aggregation), useful for compiling reports, generating dashboards, or building user interfaces to GDC data (see GDC web query interface for a non-R-based example).

### Creating a query

A query of the GDC starts its life in R. Queries follow the four metadata endpoints available at the GDC.  In particular, there are four convenience functions that each create `GDCQuery` objects (actually, specific subclasses of `GDCQuery`):

- `projects()`
- `cases()`
- `files()`
- `annotations()`

```{r projectquery}
pquery = projects()
```

The `pquery` object is now an object of (S3) class, `GDCQuery` (and `gdc_projects` and `list`). The object contains the following elements:

- fields: This is a character vector of the fields that will be returned when we [retrieve data](#retrieving-results). If no fields are specified to, for example, the `projects()` function, the default fields from the GDC are used (see `default_fields()`)
- filters: This will contain results after calling the [`filter()` method](#filtering) and will be used to filter results on [retrieval](#retrieving-results).
- facets: A character vector of field names that will be used for [aggregating data](#facets-and-aggregation) in a call to `aggregations()`. 
- archive: One of either "default" or ["legacy"](https://gdc-portal.nci.nih.gov/legacy-archive/). 
- token: A character(1) token from the GDC. See [the authentication section](#authentication) for details, but note that, in general, the token is not necessary for metadata query and retrieval, only for actual data download.

Looking at the actual object (get used to using `str()`!), note that the query contains no results. 

```{r pquery}
str(pquery)
```
### Retrieving results

[[ GDC pagination documentation ]](https://docs.gdc.cancer.gov/API/Users_Guide/Search_and_Retrieval/#size-and-from)

[[ GDC sorting documentation ]](https://docs.gdc.cancer.gov/API/Users_Guide/Search_and_Retrieval/#sort)

With a query object available, the next step is to retrieve results from the GDC. The GenomicDataCommons package.  The most basic type of results we can get is a simple `count()` of records available that satisfy the filter criteria. Note that we have not set any filters, so a `count()` here will represent all the project records publicly available at the GDC in the "default" archive"

```{r pquerycount}
pcount = count(pquery)
# or
pcount = pquery %>% count()
pcount
```

The `results()` method will fetch actual results. 

```{r pqueryresults}
presults = pquery %>% results()
```
These results are
returned from the GDC in [JSON](http://www.json.org/) format and
converted into a (potentially nested) list in R. The `str()` method is useful for taking a quick glimpse of the data.

```{r presultsstr}
str(presults[1:2])
```

A default of only 10 records are returned. We can use the `size` and `from` arguments to `results()` to either page through results or to change the number of results. Finally, there is a convenience method, `results_all()` that will simply fetch all the available results given a query. Note that `results_all()` may take a long time and return HUGE result sets if not used carefully. Use of a combination of `count()` and `results()` to get a sense of the expected data size is probably warranted before calling `results_all()`

```{r presultsall}
length(presults)
presults = pquery %>% results_all()
length(presults)
# includes all records
length(presults) == count(pquery)
```

Extracting subsets of
results or manipulating the results into a more conventional R data
structure is not easily generalizable.  However,
the
[purrr](https://github.com/hadley/purrr),
[rlist](https://renkun.me/rlist/),
and [data.tree](https://cran.r-project.org/web/packages/data.tree/vignettes/data.tree.html) packages
are all potentially of interest for manipulating complex, nested list structures. For viewing the results in an interactive viewer, consider the [listviewer](https://github.com/timelyportfolio/listviewer) package.

```{r listviewer}
library(listviewer)
jsonedit(presults)
```

### Fields and Values

[[ GDC `fields` documentation ]](https://docs.gdc.cancer.gov/API/Users_Guide/Search_and_Retrieval/#fields)

Central to querying and retrieving data from the GDC is the ability to specify which fields to return, filtering by fields and values, and faceting or aggregating. The GenomicDataCommons package includes two simple functions, `available_fields()` and `default_fields()`. Each can operate on a character(1) endpoint name ("cases", "files", "annotations", or "projects") or a `GDCQuery` object. 

```{r defaultfields}
default_fields('files')
# The number of fields available for files endpoint
length(available_fields('files'))
# The first few fields available for files endpoint
head(available_fields('files'))
```

The fields to be returned by a query can be specified following a similar paradigm to that of the dplyr package. The `select()` function is a verb that resets the fields slot of a `GDCQuery`; note that this is not quite analogous to the dplyr `select()` verb that limits from already-present fields. We *completely replace* the fields when using `select()` on a `GDCQuery`.

```{r selectexample}
# Default fields here
qcases = cases()
qcases$fields
# set up query to use ALL available fields
# Note that checking of fields is done by select()
qcases = cases() %>% select(available_fields('cases'))
head(qcases$fields)
```

### Facets and aggregation

[[ GDC `facet` documentation ]](https://docs.gdc.cancer.gov/API/Users_Guide/Search_and_Retrieval/#facets)

The GDC API offers a feature known as aggregation or faceting. By specifying one or more fields (of appropriate type), the GDC can return to us a count of the number of records matching each potential value. This is similar to the R `table` method. Multiple fields can be returned at once, but the GDC API does not have a cross-tabulation feature; all aggregations are only on one field at a time. Results of `aggregation()` calls come back as a list of data.frames (actually, tibbles).

```{r aggexample}
# total number of files of a specific type
res = files() %>% facet(c('type','data_type')) %>% aggregations()
res$type
```

Using `aggregations()` is an also easy way to learn the contents of individual fields.

### Filtering

[[ GDC `filtering` documentation ]](https://docs.gdc.cancer.gov/API/Users_Guide/Search_and_Retrieval/#filters-specifying-the-query)




## Authentication

[[ GDC authentication documentation ]](https://docs.gdc.cancer.gov/API/Users_Guide/Search_and_Retrieval/#facets)

## Datafile access and download

### Single file download

### Bulk downloads

### BAM slicing

# Use Cases

## Cases

### How many cases are there per project_id?

```{r casesPerProject}
res = cases() %>% facet("project.project_id") %>% aggregations()
head(res)
library(ggplot2)
ggplot(res$project.project_id,aes(x = key, y = doc_count)) +
    geom_bar(stat='identity') +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) 
```

### How many cases are included in all TARGET projects?

```{r casesInTCGA}
cases() %>% filter(~ project.program.name=='TARGET') %>% count()
```

### How many cases are included in all TCGA projects?

```{r casesInTARGET}
cases() %>% filter(~ project.program.name=='TCGA') %>% count()
```

### What is the breakdown of sample types in TCGA-BRCA?

```{r casesTCGABRCASampleTypes}
# The need to do the "&" here is a requirement of the
# current version of the GDC API. I have filed a feature
# request to remove this requirement.
resp = cases() %>% filter(~ project.project_id=='TCGA-BRCA' &
                              project.project_id=='TCGA-BRCA' ) %>%
    facet('samples.sample_type') %>% aggregations()
resp$samples.sample_type
```

### Fetch all samples in TCGA-BRCA that use "Solid Tissue" as a normal.

```{r casesTCGABRCASolidNormal}
# The need to do the "&" here is a requirement of the
# current version of the GDC API. I have filed a feature
# request to remove this requirement.
resp = cases() %>% filter(~ project.project_id=='TCGA-BRCA' &
                              samples.sample_type=='Solid Tissue Normal') %>%
    GenomicDataCommons::select(c(default_fields(cases()),'samples.sample_type')) %>%
    response_all()
count(resp)
res = resp %>% results()
str(res[1],list.len=6)
head(ids(resp))
```

The `listviewer` package is a great way to look into moderately-sized result sets
in an interactive web page (or, as here, embedded in an rmarkdown document).

```{r casesListViewer}
library(listviewer)
jsonedit(res)
```

## Files

### How many of each type of file are available?

```{r filesTypeCount}
res = files() %>% facet(c('type','data_type')) %>% aggregations()
res$type
ggplot(res$type,aes(x = key,y = doc_count)) + geom_bar(stat='identity') +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))     
```

### How many of each type of file are available?

```{r filesVCFCount}
res = files() %>% facet('type') %>% aggregations()
res$type
ggplot(res$type,aes(x = key,y = doc_count)) + geom_bar(stat='identity') +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))     
```

### Find gene-level RNA-seq quantification files for GBM

```{r filesRNAseqGeneGBM}
q = files() %>%
    GenomicDataCommons::select(available_fields('files')) %>%
    filter(~ cases.project.project_id=='TCGA-GBM' &
               data_type=='Gene Expression Quantification')
q %>% facet('analysis.workflow_type') %>% aggregations()
# so need to add another filter
file_ids = q %>% filter(~ cases.project.project_id=='TCGA-GBM' &
                            data_type=='Gene Expression Quantification' &
                            analysis.workflow_type == 'HTSeq - Counts') %>%
    GenomicDataCommons::select('file_id') %>%
    response_all() %>%
    ids()
```

## Downloading data

** TODO **

## Slicing 

### Get all BAM file ids from TCGA-GBM

**I need to figure out how to do slicing reproducibly in a testing environment and for vignette building**.

```{r filesRNAseqGeneGBMforBAM}
q = files() %>%
    GenomicDataCommons::select(available_fields('files')) %>%
    filter(~ cases.project.project_id == 'TCGA-GBM' &
               data_type == 'Aligned Reads' &
               experimental_strategy == 'RNA-Seq' &
               data_format == 'BAM')
file_ids = q %>% GenomicDataCommons::select('file_id') %>% response_all() %>% ids()
```


```{r slicing10}
# bamfile = slicing(file_ids[1],regions="chr12:6534405-6538375",token=token)
library(GenomicAlignments)
# aligns = readGAlignments(bamfile)
```

# sessionInfo()

```{r sessionInfo}
sessionInfo()
```

# Developer notes

- The S3 object-oriented programming paradigm is used.
- We have adopted a functional programming style with functions and methods that often take an "object" as the first argument. This style lends itself to pipeline-style programming. 
- The GenomicDataCommons package uses the [alternative request format (POST)](https://docs.gdc.cancer.gov/API/Users_Guide/Search_and_Retrieval/#alternative-request-format) to allow very large request bodies. 
